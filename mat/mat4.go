package mat

type Mat4 [16]float32

func (m Mat4) Mul(a Mat4) Mat4 {
	var out Mat4
	for i := 0; i < 4; i++ {
		for j := 0; j < 4; j++ {
			var sum float32
			for k := 0; k < 4; k++ {
				sum += m[4*k+i] * a[4*j+k]
			}
			out[4*j+i] = sum
		}
	}
	return out
}

func (m Mat4) MulAffine(a Mat4) Mat4 {
	var out Mat4

	out[4*0+0] = m[4*0+0]*a[4*0+0] +
		m[4*1+0]*a[4*0+1] +
		m[4*2+0]*a[4*0+2]
	out[4*1+0] = m[4*0+0]*a[4*1+0] +
		m[4*1+0]*a[4*1+1] +
		m[4*2+0]*a[4*1+2]
	out[4*2+0] = m[4*0+0]*a[4*2+0] +
		m[4*1+0]*a[4*2+1] +
		m[4*2+0]*a[4*2+2]
	out[4*3+0] = m[4*0+0]*a[4*3+0] +
		m[4*1+0]*a[4*3+1] +
		m[4*2+0]*a[4*3+2] +
		m[4*3+0]

	out[4*0+1] = m[4*0+1]*a[4*0+0] +
		m[4*1+1]*a[4*0+1] +
		m[4*2+1]*a[4*0+2]
	out[4*1+1] = m[4*0+1]*a[4*1+0] +
		m[4*1+1]*a[4*1+1] +
		m[4*2+1]*a[4*1+2]
	out[4*2+1] = m[4*0+1]*a[4*2+0] +
		m[4*1+1]*a[4*2+1] +
		m[4*2+1]*a[4*2+2]
	out[4*3+1] = m[4*0+1]*a[4*3+0] +
		m[4*1+1]*a[4*3+1] +
		m[4*2+1]*a[4*3+2] +
		m[4*3+1]

	out[4*0+2] = m[4*0+2]*a[4*0+0] +
		m[4*1+2]*a[4*0+1] +
		m[4*2+2]*a[4*0+2]
	out[4*1+2] = m[4*0+2]*a[4*1+0] +
		m[4*1+2]*a[4*1+1] +
		m[4*2+2]*a[4*1+2]
	out[4*2+2] = m[4*0+2]*a[4*2+0] +
		m[4*1+2]*a[4*2+1] +
		m[4*2+2]*a[4*2+2]
	out[4*3+2] = m[4*0+2]*a[4*3+0] +
		m[4*1+2]*a[4*3+1] +
		m[4*2+2]*a[4*3+2] +
		m[4*3+2]

	out[4*3+3] = 1

	return out
}

func (m Mat4) InvAffine() Mat4 {
	var out Mat4
	normInv := 1 / (m[4*0+0]*m[4*1+1]*m[4*2+2] +
		m[4*0+1]*m[4*1+2]*m[4*2+0] +
		m[4*0+2]*m[4*1+0]*m[4*2+1] -
		m[4*0+2]*m[4*1+1]*m[4*2+0] -
		m[4*0+1]*m[4*1+0]*m[4*2+2] -
		m[4*0+0]*m[4*1+2]*m[4*2+1])

	out[4*0+0] = (m[4*1+1]*m[4*2+2] - m[4*1+2]*m[4*2+1]) * normInv
	out[4*0+1] = -(m[4*0+1]*m[4*2+2] - m[4*0+2]*m[4*2+1]) * normInv
	out[4*0+2] = (m[4*0+1]*m[4*1+2] - m[4*0+2]*m[4*1+1]) * normInv
	out[4*1+0] = -(m[4*1+0]*m[4*2+2] - m[4*1+2]*m[4*2+0]) * normInv
	out[4*1+1] = (m[4*0+0]*m[4*2+2] - m[4*0+2]*m[4*2+0]) * normInv
	out[4*1+2] = -(m[4*0+0]*m[4*1+2] - m[4*0+2]*m[4*1+0]) * normInv
	out[4*2+0] = (m[4*1+0]*m[4*2+1] - m[4*1+1]*m[4*2+0]) * normInv
	out[4*2+1] = -(m[4*0+0]*m[4*2+1] - m[4*0+1]*m[4*2+0]) * normInv
	out[4*2+2] = (m[4*0+0]*m[4*1+1] - m[4*0+1]*m[4*1+0]) * normInv
	out[4*3+3] = 1
	b2 := out.Transform(NewVec3(m[4*3+0], m[4*3+1], m[4*3+2]))
	out[4*3+0] = -b2[0]
	out[4*3+1] = -b2[1]
	out[4*3+2] = -b2[2]
	return out
}

func (m Mat4) Transform(a Vec3) Vec3 {
	return Vec3{
		m[4*0+0]*a[0] + m[4*1+0]*a[1] + m[4*2+0]*a[2] + m[4*3+0],
		m[4*0+1]*a[0] + m[4*1+1]*a[1] + m[4*2+1]*a[2] + m[4*3+1],
		m[4*0+2]*a[0] + m[4*1+2]*a[1] + m[4*2+2]*a[2] + m[4*3+2],
	}
}

func (m Mat4) TransformX(a Vec3) float32 {
	return m[4*0+0]*a[0] + m[4*1+0]*a[1] + m[4*2+0]*a[2] + m[4*3+0]
}

func (m Mat4) TransformY(a Vec3) float32 {
	return m[4*0+1]*a[0] + m[4*1+1]*a[1] + m[4*2+1]*a[2] + m[4*3+1]
}

func (m Mat4) TransformZ(a Vec3) float32 {
	return m[4*0+2]*a[0] + m[4*1+2]*a[1] + m[4*2+2]*a[2] + m[4*3+2]
}
